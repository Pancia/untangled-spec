(ns smooth-test.parser.parse)

#?(:cljs
   (defn mock [rv] (fn [&rest] rv))
   )


#?(:clj
   (defn parse-clock-tick [acc [assertion arrow time_ms]]
     (if (= assertion 'clock-ticks)
       (update-in acc [:steps] #(conj % `{:type   :clock-tick
                                          :time   ~time_ms
                                          :action (fn [level#] (smooth-test.core/print-title level# "ADVANCE CLOCK"))
                                          }))
       acc
       )
     ))

#?(:clj
   (defn parse-assertion [acc [assertion arrow result]]
     (if (= assertion 'clock-ticks)
       acc
       (update-in acc [:steps] #(conj % `{:type     :assertion
                                          :action   (fn [] ~assertion)
                                          :expected (fn [] ~result)
                                          }))
       )
     )
   )

#?(:cljs
   (defn run-specification [tests]
     (loop [t tests]
       (if (empty? t)
         nil
         (do
           ((first t) 1)
           (recur (rest t))
           )))
     )
   )

#?(:cljs
   (defn run-behaviors [level behaviors]
     (loop [t behaviors]
       (if (empty? t)
         nil
         (do
           ((first t) level)
           (recur (rest t))
           )))
     )
   )

#?(:clj
   ; Specification title forms+
   ; forms -> functions generated by
   ;      info, behavior, provided
   (defmacro specification [title & forms]
     (let [tests (into [] forms)
           sym (symbol title)]
       `(defn ~sym []
          (smooth-test.core/print-title 0 ~title)
          (run-specification ~tests)
          )
       ))



  :clj
   (defmacro info [description]
     `(fn [level#] (smooth-test.core/print-title level# ~description)))
   )



#?(:clj
   (defn build-advance-clock [tm]
          (let [sym (gensym "advance-clock")]
            `(fn ~sym [level#]
               (smooth-test.core/print-title level# (str "Advancing clock " ~tm "ms")))
            ))
   )

#?(:clj
   (defn build-assertion [assertion]
     (let [sym (gensym "assertion")]
       `(fn ~sym [level#]
          (let [actual# ((:action ~assertion))
                expected# ((:expected ~assertion))]
            (if (= actual# expected#)
              (smooth-test.core/print-title level# "TEST OK.")
              (smooth-test.core/print-title level# (str "TEST FAILED. Expected " expected# " but got " actual#))
              )
            )
          )
       )
     )
   )


#?(:clj
   (defn build-behavior-step-function [step]
     (cond
       (= :assertion (:type step))  (build-assertion step)
       (= :clock-tick (:type step)) (build-advance-clock (:time step))
       )
     )
   )

; Behavior: title step+
; step: clock-tick | assertion
; clock-tick: 'clock-ticks '=> ms_number
; assertion: runnable arrow checker
; checker: value | fn
#?(:clj
   (defmacro behavior [description & forms]
     (let [steps (partition 3 forms)
           parsed-steps (reduce (fn [acc step] (-> acc (parse-clock-tick step) (parse-assertion step))) {:steps []} steps)
           step-fns (into [] (map build-behavior-step-function (:steps parsed-steps)))
           sym (gensym "behavior")
           ]
       `(fn ~sym [level#]
          (smooth-test.core/print-title level# ~description)
          (run-behaviors (inc level#) ~step-fns)
          )
       ))
   )

#?(:clj
   (defn parse-mocking-clause [acc [the-call arrow value-to-return]]
     (let [function-to-mock (first the-call)
           args-to-expect (rest the-call)]
       (update acc :setup #(conj % {:function function-to-mock :return value-to-return}))))
   )

#?(:clj
   (defn stackmocks [mocks testname levelname]
     (if (empty? mocks)
       `(~testname ~levelname)
       `(with-redefs ~(first mocks) ~(stackmocks (rest mocks) testname levelname))
       )
     )
   )

#?(:clj
   (defn is-mocking-clause? [triple] (not (and (sequential? (first triple)) (= "behavior" (name (first (first triple)))))))
   )

#?(:cljs
   (defn run-behaviors-with-provided [level setupfn behaviors]
     (loop [t behaviors]
       (if (empty? t)
         nil
         (do
           (setupfn (first t) level)
           (recur (rest t))
           )))
     )
   )

#?(:clj
   ; clauses-and-behaviors: mocking-clause+ behavior+
   (defmacro provided [description & forms]
     (let [mocking-clauses (take-while is-mocking-clause? (partition-all 3 forms))
           non-mocking-clauses (drop (* 3 (count mocking-clauses)) forms)
           behaviors (filter #(= "behavior" (name (first %))) non-mocking-clauses)
           sub-provides (filter #(= "provided" (name (first %))) non-mocking-clauses)
           tests (into [] (macroexpand-1 behaviors))
           testp (into [] (macroexpand sub-provides))
           setup (reduce parse-mocking-clause {:title description :setup []} mocking-clauses)
           bindings (map (fn [clause] [(:function clause) `(smooth-test.parser.parse/mock (:return ~clause))]) (:setup setup))
           testname (gensym "test")
           setupname (gensym "setup")
           levelname (gensym "level")
           mocks (stackmocks bindings testname levelname)
           setupfn `(fn ~setupname [~testname ~levelname] ~mocks)
           sym (gensym "provided")
           ]
       `(fn ~sym [level#]
          (let [setupfn# ~setupfn
                behavior-tests# ~tests]
            (smooth-test.core/print-title level# ~description)
            (run-behaviors-with-provided (inc level#) setupfn# behavior-tests#)
            )
          )
       )
       )
   )
